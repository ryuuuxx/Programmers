
$$ key point
< 배열의 중복제거 조건 >
1. 중복제거 함수 사용
2. 각 요소들의 순서 유지 


< 사용할 수 있는 함수 >
- set : 중복 제거 가능, but 순서 유지 안됨 (탈락)
- for문 : 중복 제거 가능, 순서 유지 됨 (v)


< 코드 짜본 순서 >
1. 중복 제거된 값들이 들어갈 리스트를 하나 더 생성 (sorted_arr)
2. for 반복문에서 원래 리스트를 하나씩 돌면서 sorted_arr 리스트에 값을 넣음
3. 이때 값을 넣으면서 sorted_arr 리스트에 이미 있는 값인지 확인

그래서 처음에 for문을
for num in arr:
    if num not in sorted_arr:
        sorted_arr.append(num) 

이렇게 짜니까 만약에 1,1,1,3,3,3,0,0,1,1 >> 1,3,0,1 이 되어야되는데 뒤에 1이 안저장됨 ;;
그래서 열심히 gpt를 두들기고 머리를 뜯어본결과


앞뒤로 붙어있는 숫자들을 비교해서 다른숫자면 sorted_arr 리스트 끝에 추가하는 방식으로 바꿈.
그러니까 해결 완,,,
근데 또 sorted_arr에 arr의 첫번째 요소를 넣어줘야만 잘 실행되더라..
이건 오ㅐ 그런지 지피티 쓰앵님께 여쭤봤더니



"""
첫 번째 값 비교 문제: for 루프는 arr[1]부터 시작해서 이전 값(arr[0])과 비교합니다. 
만약 첫 번째 값이 sorted_arr에 없다면, sorted_arr는 비어 있어 처음에 비교할 값이 없어지므로 
첫 번째 값을 처리할 수 없습니다.

중복 제거 논리: 코드의 핵심은 현재 값(arr[num])과 이전 값(arr[num - 1])을 비교하여 중복된 값을 제외하는 방식입니다. 
이 비교가 제대로 이루어지려면 sorted_arr에 최소한 첫 번째 값이 미리 들어 있어야만 합니다.

만약 첫 번째 값을 미리 넣지 않는다면, 다음과 같은 문제가 발생할 수 있습니다:

첫 번째 값은 루프의 비교 과정에 포함되지 않게 되고, sorted_arr에 추가되지 않습니다.
따라서, sorted_arr = [arr[0]]로 초기화하여 첫 번째 값을 미리 넣어주어야만 중복되지 않은 리스트를 완성할 수 있습니다.
"""


해결 완.
